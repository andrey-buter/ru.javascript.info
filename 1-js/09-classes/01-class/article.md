
# Основной синтаксис класса

```quote author="Википедия"
В объектно-ориентированном программировании *класс* - это расширяемый шаблон кода программы для создания объектов, предоставляющий изначальное значение для состояния (свойства) и реализации поведения (функции или методы).
```

На практике нам часто приходится создавать множество объектов одного и того же вида, например, пользователи, товары или что-то в этом роде.

Как мы уже знаем из главы <info:structor-new>, с этим может помочь `new function`.

Но в современном JavaScript есть более продвинутая конструкция - "класс", которая предоставляет новые возможности, полезные для объектно-ориентированного программирования.

## Синтаксис "класса"

Основной синтаксис такой:
```js
class MyClass {
  // class methods
  // методы класса
  constructor() { ... }
  method1() { ... }
  method2() { ... }
  method3() { ... }
  ...
}
```

Затем `new MyClass()`создаст новый объект со всеми перечисленными методами.

Метод `constructor()` вызывается автоматически командой `new`, поэтому мы можем инициализировать объект там.

Например:

```js run
class User {

  constructor(name) {
    this.name = name;
  }

  sayHi() {
    alert(this.name);
  }

}

// Использование:
let user = new User("John");
user.sayHi();
```

Когда вызывается `new User("John")`:
1. Создаётся новый объект.
2. Вызывается `constructor` с полученными аргументами и происходит присваивание `this.name`.

...Затем мы вызываем методы, например, `user.sayHi`.


```warn header="Запятая между методами класса отсутствует"
Частая ловушка для начинающих разработчиков -- это ставить запятую между методами класса, что может привести к синтаксической ошибке.

Не стоит путать нотацию здесь с объектными литералами. Внутри класса запятые не требуются.
```

## Что такое класс?

Так что же такое `класс`? Это совсем не новая языковая сущность, как можно подумать.

Давайте раскроем все волшебство и посмотрим, что такое класс на самом деле. Это поможет понять многие сложные аспекты.

В JavaScript класс -- это своего рода функция.

Вот, посмотрите:

```js run
class User {
  constructor(name) { this.name = name; }
  sayHi() { alert(this.name); }
}

// Доказательство: Пользователь - это функция
*!*
alert(typeof User); // function
*/!*
```

Что на самом деле делает конструкция `class User {...}`, так это:
1. Создаёт функцию под названием `User`, которая становится результатом объявления класса.
    - Код функции взят из метода `constructor` (считается пустым, если мы не пишем такой метод).
3. Хранит все методы, такие как `sayHi`, в `User.prototype`.

В дальнейшем, для новых объектов, когда мы вызываем метод, он берётся из прототипа, как описано в главе <info:function-prototype>. Таким образом, объект `new User` имеет доступ к методам класса.

Мы можем проиллюстрировать результат `class User` как:

![](class-user.png)

Вот код для самостоятельного разбора:


```js run
class User {
  constructor(name) { this.name = name; }
  sayHi() { alert(this.name); }
}

// класс это функция
alert(typeof User); // function

// ...или, точнее, метод constructor.
alert(User === User.prototype.constructor); // true

// Методы представлены в User.prototype, например
alert(User.prototype.sayHi); // alert(this.name);

// В прототипе есть ровно два метода
alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi
```

## Не только синтаксический сахар

Иногда люди говорят, что `class` -- это "синтаксический сахар" в JavaScript, потому что мы можем объявить то же самое без слова `class` вообще:

```js run
// перезапишем класс User с помощью только функций

// 1. Создаём функцию-конструктор
function User(name) {
  this.name = name;
}
// любой прототип функции по умолчанию имеет метод constructor,
// так что нам не нужно его создавать

// 2. Добавляем метод к прототипу
User.prototype.sayHi = function() {
  alert(this.name);
};

// Использование:
let user = new User("John");
user.sayHi();
```

Результат этого определения примерно тот же. Таким образом, действительно, есть причины, по которым `class` можно считать синтаксическим сахаром для определения конструктора вместе с его прототипными методами.

Хотя, есть важные различия.

1. Во-первых, функция, созданная с помощью `class`, помечена специальным внутренним свойством `[[FunctionKind]]:"classConstructor"`. Так что это не совсем то же самое, если создавать его вручную.

    В отличие от обычной функции, конструктор класса не может быть вызван без `new`:

    ```js run
    class User {
      constructor() {}
    }

    alert(typeof User); // function
    User(); // Ошибка: Конструктор класса User не может быть вызван без 'new'.
    ```

    Также, строковое представление конструктора класса в большинстве JavaScript движков начинается с "class..."

    ```js run
    class User {
      constructor() {}
    }

    alert(User); // class User { ... }
    ```

2. Методы классов не перечисляются
    A class definition sets `enumerable` flag to `false` for all methods in the `"prototype"`.
    Определение класса устанавливает флаг `перечисляемый` в `false` для всех методов в `"prototype"`.

    Это хорошо, потому что если мы делаем `for..in` с объектом, то обычно нам не нужны методы его класса.

3. Классы всегда `use strict`
    Весь код внутри конструкции класса автоматически находится в строгом режиме.


Кроме того, синтаксис `class` имеет множество других особенностей, которые мы рассмотрим позже.

## Class Expression

Также, как и функции, классы могут быть определены внутри другого выражения, переданы, возвращены, назначены и т.д.

Вот пример классового выражения:

```js
let User = class {
  sayHi() {
    alert("Hello");
  }
};
```

Подобно именованным Function Expressions, class expressions могут иметь или не иметь имя.

Если выражение класса имеет имя, то оно видно только внутри класса:

```js run
// "Именованное классовое выражение" (увы, такого термина нет, но это то, что происходит).
let User = class *!*MyClass*/!* {
  sayHi() {
    alert(MyClass); // MyClass виден только внутри класса
  }
};

new User().sayHi(); // работает, показывает определение MyClass

alert(MyClass); // ошибка, MyClass не виден вне класса
```


Мы даже можем динамически создавать классы "по требованию", например:

```js run
function makeClass(phrase) {
  // declare a class and return it
  // объявить класс и вернуть его
  return class {
    sayHi() {
      alert(phrase);
    };
  };
}

// Создаём новый класс
let User = makeClass("Hello");

new User().sayHi(); // Hello
```


## Геттеры/сеттеры, другие shorthands

Классы также включают геттеры/сеттеры, генераторы, вычисленные свойства и т.д.

Вот пример для `user.name`, реализованного с помощью `get/set`:

```js run
class User {

  constructor(name) {
    // вызывает сеттер
    this._name = name;
  }

*!*
  get name() {
*/!*
    return this._name;
  }

*!*
  set name(value) {
*/!*
    if (value.length < 4) {
      alert("Name is too short.");
      return;
    }
    this._name = value;
  }

}

let user = new User("John");
alert(user.name); // John

user = new User(""); // Имя слишком короткое.
```

Внутри, геттеры и сеттеры создаются в `User.prototype`, подобно этому:

```js
Object.defineProperties(User.prototype, {
  name: {
    get() {
      return this._name
    },
    set(name) {
      // ...
    }
  }
});
```

Вот пример с вычисленными свойствами:

```js run
function f() { return "sayHi"; }

class User {
  [f()]() {
    alert("Hello");
  }

}

new User().sayHi();
```

Для генераторного метода аналогично, представьте его с помощью `*`.

## Свойства класса

```warn header="Старым браузерам могут понадобиться полифилы"
Специальные свойства класса являются недавним дополнением к языку.
```

В приведённом выше примере, `User` имел только методы. Давайте добавим свойство:

```js run
class User {
  name = "Anonymous";

  sayHi() {
    alert(`Hello, ${this.name}!`);
  }
}

new User().sayHi();
```

Свойство не помещается в `User.prototype`. Вместо этого, он создаётся с помощью `new`, отдельно для каждого объекта. Таким образом, у каждого объекта одного и того же класса  всегда будут свои собственные свойства.


## Итого

JavaScript предоставляет множество способов создания класса.

Во-первых, согласно общей объектно-ориентированной терминологии, класс - это класс, предоставляющий "шаблоны объектов", позволяющий создавать одни и те же структурированные объекты.

Когда мы говорим "класс", это не обязательно означает ключевое слово `class`.

Это класс:

```js
function User(name) {
  this.sayHi = function() {
    alert(name);
  }
}
```

...Но в большинстве случаев используется ключевое слово `class`, так как оно обеспечивает отличный синтаксис и множество дополнительных возможностей.

Базовый синтаксис класса выглядит следующим образом:

```js
class MyClass {
  prop = value; // свойство

  constructor(...) { // конструктор
    // ...
  }

  method(...) {} // метод

  get something(...) {} // геттер
  set something(...) {} // сеттер

  [Symbol.iterator]() {} // метод с вычисленным именем/названием символа
  // ...
}
```

Технически, `MyClass` - это функция, а методы прописаны в `MyClass.prototype`.

В следующих главах мы узнаем больше о классах, включая наследование и другие особенности.
